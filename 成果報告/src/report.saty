@require: itemize

@require: code-printer/code-printer
@require: code-printer/code-syntax
@require: code-printer/code-theme
@require: enumitem/enumitem
@require: figbox/figbox

@import: mitou-report
@import: util

let font-ratio-latin = 1.
let font-ratio-cjk = 0.88
let font-latin-roman  = (`Junicode`   , font-ratio-latin, 0.)
let font-latin-italic = (`Junicode-it`, font-ratio-latin, 0.)
let font-latin-sans   = (`lmsans`    , font-ratio-latin, 0.)
let font-latin-mono   = (`lmmono`    , font-ratio-latin, 0.)
let font-cjk-mincho   = (`ipaexm`    , font-ratio-cjk  , 0.)
let font-cjk-gothic   = (`ipaexg`    , font-ratio-cjk  , 0.)

let-block +python code = '<+code-printer ?:(CodePrinter.make-config CodeSyntax.python CodeTheme.basic-dark)(code);>

let-inline \footnote-link url = {\footnote{\href(url)(embed-string(url));}}
let-inline ctx \gt inner =
    let ctx-emph =
        ctx |> set-font Latin font-cjk-gothic
            |> MitouReport.set-cjk-font font-cjk-gothic
    in
        read-inline ctx-emph inner

open EnumitemAlias
open FigBox
in
document (|
    creators = [{芝山 駿介}];
    jouzai-number = 177;
    manager = {竹迫 良範};
    project = {
        Pythonにトランスパイル可能な\fil-both;静的型付けプログラミング言語の開発
    };
    year = 2023;
    submission-month = 3;
    submission-date = 8;
|) '<
    +section{要約}<
        +p{
            本プロジェクトでは，Pythonにトランスパイル可能な静的型付けプログラミング言語Ergの開発を行ない，
            また開発ツール群(Language Server，パッケージマネージャ，インストーラ，パッケージレジストリ，パッケージレジストリサイト)も実装した．
        }
    >
    +section{背景及び目的}<
        +subsection{背景}<
        +p{
            Python\footnote-link(`https://python.org`);は，産業用・教育用途を問わず世界中で幅広く利用されている汎用プログラミング言語である．
            特に，機械学習やデータ分析の分野での利用が増加しており，その需要は今後も続くと予想される．
        }
        +p{
            しかし，Pythonは実行時にコードの正当性を検証する動的型付け言語であるため，
            静的型付け言語に比べてバグの発見が遅れ，開発効率が低下するという傾向がある．
            また，Pythonはそのシェアに比べて，公式の提供する開発環境が不十分であるという問題もある．
            したがってサードパーティの開発ツールがOSS・商用を問わず多く存在するが，これは開発者にとって
            選定のコストが大きく，またそれらのツールの互換性による問題が発生することがある．
        }
        +p{
            動的型付け言語のデメリットを解消するべく，動的型付け言語に静的型システムを導入したプログラミング言語を開発するというプロジェクトがある．
            代表的なものがTypeScript\footnote-link(`https://typescriptlang.org`);であり，
            これはJavaScript\footnote-link(`https://developer.mozilla.org/ja/docs/Web/JavaScript/`);に静的型システムを導入した言語である．
            TypeScriptはIT系ナレッジサイトstackoverflowが2023年に行ったプログラミング言語の人気調査
            \footnote-link(`https://survey.stackoverflow.co/2023/#most-popular-technologies-language/`);で5位にランクインするなど，大きな成功を収めている．
            従って，JavaScriptと同じく動的型付け言語であるPythonに対して静的型システムを導入したプログラミング言語を開発することは，潜在的に大きな需要があると考えられる．
        }
        +p{
            Pythonをトランスパイル(変換)ターゲットとするプログラミング言語はいくつか存在する\footnote-link(`https://hylang.org`);\footnote-link(`https://coconut-lang.org`);が，
            その多くは動的型付け言語であり，Pythonの問題をそのまま引き継いでいる．
            Pythonとの連携を重視したプログラミング言語としてJulia\footnote-link(`https://julialang.org`);があり，
            この言語は静的型付けを部分的に採用しているが，これはあくまで実行効率向上を目的とするところが大きく，動的型付けのコードを混入させることもできてしまう．
            Pythonとの互換性を謳う静的型付け言語としては，2023年に発表されたMojo\footnote-link(`https://mojolang.org`);があるが，この言語もやはり実行効率のために静的型付けを採用していると思われ，
            Python APIの静的型付け化を指向しているとは言い難い．
        }
        +p{
            Pythonには型アノーテーションの文法があるため，これを用いて擬似的に静的型付けを行おうとするプロジェクト\footnote-link(`https://mypy-lang.org`);もある．
            しかしこのアプローチには大きく2つの問題がある．
            まず１つ目は，型アノーテーションはあくまでコメントのようなものであり，実行時には無視されるため，コードの安全性を真の意味で担保することはできないという問題がある．
            次に，この手のプロジェクトでは，大抵Pythonコードの型推論を行わない(行えない)ため，至るとところに型アノーテーションを付ける必要があり，大きな負担となる問題がある．
            Pythonコードの型推論をベストエフォートで行う検査器\footnote-link(`https://github.com/google/pytype`);もあるが，Pythonの文法上自ずと限界がある．
        }
        +p{
            従って，本プロジェクトのように，Python APIとの互換性を保証しながら，完全な静的型付けの達成を狙うプログラミング言語および型検査器はこれまで確認された限りにおいて存在しない．
            以上が本プロジェクトを提案するに至った背景である．
        }
        >
        +subsection{目的}<
        +p{
            前節のような問題を解決するために，本プロジェクトではPythonにトランスパイル可能な静的型付けプログラミング言語Ergをおよびその開発ツールを開発する．
            Erg言語はPythonにトランスパイルされるためPythonのコード資産をそのまま再利用でき，また静的型システムによる高い静的検証能力を持つ．
            また開発ツール群をコマンド一つで呼び出せるようにすることで，低い環境構築コストと高い再現性を実現する．
        }
        >
    >
    +section{プロジェクト概要}<
    +p{
        本プロジェクトでは，Pythonにトランスパイル可能な静的型付けプログラミング言語Ergおよびその開発ツール群の開発を行なった．
        言語仕様は公式サイト\footnote-link(`https://erg-lang.org/the-erg-book/`);およびリポジトリ
        \footnote-link(`https://github.com/erg-lang/erg/tree/main/doc/JA`);で公開されており，殆どの機能が実装済みである．
        コンパイラはRust\footnote-link(`https://rust-lang.org`);で実装されており，
        MIT\footnote-link(`https://opensource.org/license/mit/`);およびApache 2.0
        \footnote-link(`https://opensource.org/license/apache-2-0/`);のデュアルライセンスで公開されている
        \footnote{これはRust製のプロジェクトではよく見られるライセンス形態であり，ユーザはMITライセンスのように制限の少ないライセンスか，
        Apache 2.0ライセンスのように特許権への言及など商用利用者にとって使いやすいライセンスのどちらかを選択できる．}．
        OSはLinux，macOS，Windowsに対応している．
        開発ツール群は，Language Server（\ref(`lang-server`);節で説明），パッケージマネージャ，インストーラ，
        パッケージレジストリおよびレジストリの登録済みパッケージを確認できるWebサイトを開発した．
    }
    >
    +section{開発内容} <
        +subsection?:(`compiler`){コンパイラ}<
        +p{
            ErgコンパイラはRustで実装されており，MIT/Apache 2.0ライセンスで公開されている．

            本プロジェクト採択前からプロトタイプとして開発を進めていたが，採択後は全体のアーキテクチャの再設計，コンパイラの並列化などに対応したほか，
            多くのバグ修正と機能追加を行なった．
        }
        +p{
            Rustを開発言語として採用したのは，Rustが言語処理系などを含むシステムソフトウェアの開発言語として設計されたシステムプログラミング言語であり，
            高い実行効率とメモリ安全性を兼ね備えていると判断したためである．
        }
        +p{
            コンパイラは`erg`コマンドで呼び出せるが，`erg`コマンドは後述するLanguage Serverやパッケージマネージャを呼び出すこともできるため，
            コンパイラ専用のコマンドというわけではない．

            図1にコンパイラのアーキテクチャについての概説図を示す．
        }
        +fig-center(
            vconcat ?:align-center [
            include-image 400pt `img/compiler_arch.jpg`;
            gap 10pt;
            textbox {図1: コンパイラの概説図};
        ]);
        +p{
            これは静的型付け言語のコンパイラとしては一般的な構成であるが，以下に詳しく説明する．
            なお以下では，字句解析器から型検査器・副作用検査器・所有権検査器までの部分をフロントエンド，コード生成器の部分をバックエンドと呼ぶ．
        }
        +p{
            まず，Erg言語のソースコードは字句解析器によってトークン列に変換される．
            トークン列の変換によってスペースやコメントなどの無視されるべき文字列は除去され，インデントの解釈なども行われる．
        }
        +p{
            次に，トークン列は構文解析器によって抽象構文木（AST）に変換される．
            構文解析器は再帰下降構文解析を行い，文法エラーを検知しても可能な限り解析を続行する．
            また構文解析のあと，AST中のパターンマッチなどの構文糖は脱糖される．
        }
        +p{
            名前解決器は，ASTからモジュールのインポートを探し出し，そのインポート先のモジュールとの関連付けを行う．
            そのようにして構築した依存関係グラフに従ってモジュールの意味検査プロセスの実行計画を立てる．
        }
        +p{
            型検査器は，ASTを走査して各式の型推論および型検査を行い，ASTに型情報が付加された中間表現（HIR）を生成する．
            コンパイル時評価器は型推論・型検査の過程で必要となる式の評価を行う．型検査器およびその基盤となる静的型システムは非常に重要な部分であるため，
            \ref(`type-system`);節で詳しく説明する．
            本プロジェクト中は実装しなかったが，将来的にはユーザ定義のコンパイル時関数を評価可能として実行時の計算量を削減することも可能になる予定である．
        }
        +p{
            副作用検査器は，HIRを走査して不正な副作用の使用がないか検査する．
        }
        +p{
            所有権検査器は，HIRを走査して参照やmove(\ref(`lang-spec`);節の「所有権」の項を参照)が正当に行われているか検査する．
        }
        +p{
            最後にHIRを結合してコード生成器に渡し，コード生成器はそれを用いて単一のpycファイルを生成する．
            コード生成器はいくつかのバックエンドが実装されているが，現在最も開発が進んでいるのはPythonバイトコード(pycファイル)を生成するバックエンド(以下，pycバックエンドと呼称する)である．
            PythonバイトコードはPythonインタプリタ（CPython）が実行可能な仮想機械語であり，
            「Pythonにトランスパイル可能」というのは主にpycバックエンドの能力を指している．
            Pythonバイトコードは各バージョンによって互換性が保証されないため，pycバックエンドは現在のところPython 3.7~3.11をサポートしている．
            直接Pythonスクリプトを出力するバックエンドも開発したが，pycバックエンドの完成度向上を最優先課題としたため，こちらは一部機能が未実装である．
            また，Rustコードへトランスパイルすることでネイティブコード出力を可能とするバックエンドの開発も行ったが，同様の理由でこちらも基本的機能の実装に留まった．
        }
        +p{
            コンパイルの各ステージで発生したエラーは収集され，一度にユーザに報告される．
            エラーは該当箇所のコードとともに提示され，エラーメッセージもユーザにとって理解しやすいものとなるよう努めた（図2）．
        }
        +fig-center(
            vconcat ?:align-center [
            include-image 400pt `img/error_msg.jpg`;
            gap 10pt;
            textbox {図2: エラーメッセージの例};
        ]);
        +p{
            なお，`erg`コマンドで直接ファイル名を指定した場合，生成されたpycファイルは即座にPythonインタプリタに渡され実行される(実行後ファイルは残らない)．
            pycファイルのみを出力したい場合は，`erg compile`サブコマンド，検査だけを行いたい場合は`erg check`サブコマンドを使う．
        }
        >
        +subsection{PythonパッケージとしてのErgコンパイラ}<
        +p{
            Ergコンパイラは，PythonパッケージとしてPythonインタプリタが動的に呼び出すこともできるようにした．
            これにより，Ergモジュールを実行時に読み込んだり，ErgコードのASTを直接操作したりすることが可能になる．
            Pythonでのコード例を以下に示す．
        }
        +python(`# Python
import erg_compiler
from erg_compiler import erg_parser
compiler = erg_compiler.Compiler(deps=[])
code = compiler.compile(".i = 0", "exec")
exec(code)
assert i == 0

mod = erg_parser.parse(".j = 1")
ast = erg_parser.ast.AST.new("test", mod)
test = erg_compiler.exec_ast(ast)
j = test.__dict__["j"]
assert j == 1
`);
        +p{
            APIの型定義も行ったので，ErgからErgコンパイラを操作することも可能である．
            Pythonパッケージ化にはpyo3\footnote-link(`https://pyo3.rs`);を用いた．これはRustとPythonの間での相互運用を可能にするライブラリである．
        }
        >
        +subsection?:(`lang-spec`){言語仕様}<
        +p{
            Ergは以下の設計思想に基づいて設計されている．
            \listing{
                * 強い静的型付け
                * ミニマルな基礎文法
                * 高い表現能力
                * Python APIとの互換性
                * 高い開発効率
            }
        }
        +p{
            以下ではErgの言語仕様を概説する．詳細な資料はインターネット上で公開されている
            \footnote-link(`https://erg-lang.org/the-erg-book/`);のでそちらも参照されたい．
        }
        +description<
            +ditem{\gt{変数定義・関数定義}}{}<
            +pn{
                変数はPythonと同様の文法で定義できるが，再代入はできない．
                これは関数型言語ではよく見られる仕様で，再代入がないことでプログラムの挙動を追いやすくなるといったメリットがある．
            }
            +python(`i = 1
i = 2 # NameError: variable i cannot be assigned more than once
`);
            +pn{
                大文字で始まる変数は定数を表す．定数はコンパイル時に値が確定していなければならない．
            }
            +python(`TWO = 1 + 1
PI = 3.14
`);
            +pn {
                変数は明示的に型指定できるが，型推論が行われるため省略することもできる．
            }
            +python(`i: Int = 1
a: Array(Int) = [1, 2, 3]
`);
            +pn{
                関数はPythonとは少し異なる文法で定義される．これはHaskellなどの関数型言語の影響を受けている．

                関数も変数と同様に型指定できるほか，型推論によって省略することもできる．引数リストの`()`は戻り値型を指定しない場合省略できる．
            }
            +python(`add x, y = x + y
iadd(x: Int, y: Int): Int = x + y
`);
            +pn{
                デフォルト引数は以下のような文法でサポートしている．
            }
            +python(`isum iterable: Iterable(Int), start := 0 =
    sum(iterable, start)
`);
            +pn{
                多相関数の明示的な型指定は以下のような文法でサポートしている．
            }
            +python(`id|T|(x: T): T = x
add|A <: Add(R)|(x: A, y: R): A.Output =
    x + y
`);
            >
            +ditem{\gt{関数呼び出し}}{}<
            +pn{
                関数呼び出しはPythonとほぼ同様の文法で行うことができる．呼び出しの`()`は意味が一意に定まる場合省略できる．
            }
            +python(`f(1, 2)
f 1, 2
`);
            +pn{
                キーワード引数も以下のような文法でサポートしている．
            }
            +python(`sum([1, 2, 3], start:=1)
`);
            +pn{
                Ergのサブルーチンの中には，副作用を許容するものと許容しないものがある．
                副作用を許容するものは手続きまたはプロシージャ（procedure）と呼ばれ，それ以外のものは関数（function）と呼ばれる．
                Pythonの関数は手続きに対応するので注意されたい．
                プロシージャはポストフィックスとして!をつける必要がある．
                これにより，コードに副作用があるのかないのかを一目で判断することができる．
            }
            +python(`add 1, 2 # no side-effect
print! 1, 2 # side-effect
`);
            >
            +ditem{\gt{組み込みサブルーチン}}{}<
            +pn{
                Ergには，Pythonの組み込み関数に加えてErg独自の組み込みサブルーチンが実装されている．以下に主要なものを示す．
                \listing{
                    * print!: 標準出力に出力する
                    * open!: ファイルを開く
                    * len: コンテナオブジェクトの長さを返す
                    * sum: コンテナオブジェクトの要素を合計する
                    * range: rangeオブジェクトを生成する
                    * zip: 複数のコンテナオブジェクトをまとめる
                    * map: 関数をコンテナオブジェクトの各要素に適用する
                    * exit: プログラムを終了する
                    * for!: コンテナオブジェクトの各要素に対して処理を行う
                    * if!: 条件によって処理を分岐する
                    * while!: 条件が真の間処理を繰り返す
                    * match!: パターンマッチングを行う
                }
                特筆するべきは，`for!`や`if!`，`while!`，`match!`などの制御構造がErgでは単なる手続きである点である．以下がその使用例である．
            }
            +python(`for! [1, 2, 3], i =>
    print! i

if! True:
    do!:
        print! "True"
    do!:
        print! "False"

while! True, do!:
    print! "loop"

match! 1:
    1 => print! "one"
    2 => print! "two"
    _ => print! "other"
`);
            +p{
                これにより，Ergではこれらの手続きを組み合わせて容易に新しい制御構造を定義することができる．
            }
            >
            +ditem{\gt{組み込み型}}{}<
            +pn{
                組み込み型は、Pythonの組み込み型とほぼ同じものがサポートされている．主要なものを以下に示す．
                \listing{
                    * 整数型(Int)
                    * 浮動小数点数型(Float)
                    * 真偽値型(Bool)
                    * 文字列型(Str)
                    * None型(NoneType)
                    * バイト列型(Bytes)
                    * 配列型(Array)
                    * 辞書型(Dict)
                    * タプル型(Tuple)
                    * 集合型(Set)
                    * 関数型(Func)
                }
                このほか，Erg独自の組み込み型として以下のものがサポートされている．
                \listing{
                    * 自然数型（Nat: 0以上の整数で，Intのサブタイプ）
                    * プロシージャ型（Proc: 手続き，すなわち副作用を許容するサブルーチンの型，Pythonの関数に対応するのはこちら）
                    * レコード型（Record）
                }
                レコードはJavaScriptのオブジェクト記法に似たものであり，以下のような文法で定義できる．
            }
            +python(`p = { .x = 1; .y = 1 }
assert p.x == 1 and p.y == 1
`);
            +pn{
                また，IntやArrayなどにはそのサブタイプとして内部可変性を持つ型が存在する（Int!, Array!など）．
                Ergでは型にポストフィックスとして!を付けることで内部可変性を指定できる．つまり!の付かない型と
                サブルーチン(関数)のみを使えば，純粋関数型言語としてErgを使うことが可能である．
            }
            >
            +ditem{\gt{クラスの定義}}{}<
            +pn{
                クラスの定義は，以下のような文法で行うことができる．
            }
            +python(`Point2D = Class {
    x = Int
    y = Int
}
`);
            +pn{
                メソッドの定義は，以下のような文法で行うことができる．
            }
            +python(`Point2D.
    norm(self) = self.x ** 2 + self.y ** 2
`);
            +pn{
                このようにして定義されたクラスは以下のようにしてインスタンス化できる．
            }
            +python(`p = Point2D.new {x = 1; y = 2}
assert p.norm() == 5
`);
            +pn{
                newはインスタンスを生成するスタティックメソッド（コンストラクタ）であり，ユーザがカスタムすることもできる．
            }
            +python(`Point2D.
    new(x: Int, y: Int) =
        Point2D {x = x; y = y}

p = Point2D.new(1, 2)
`);
            >
            +ditem{\gt{所有権}}{}<
            +pn{
                Ergにはオブジェクトの所有権の概念が存在する．
                これはRustに影響を受けたものであるが，若干簡略化されている．
                Ergでは，可変オブジェクトの所有権はただ一つである．所有権が移動した後の変数にアクセスするとコンパイルエラーが発生する．
                以下がそのコード例である．空の可変配列は`![]`で生成するが，これを束縛する変数は，ただ一つのみに制限される．
            }
            +python(`arr = ![]
arr2 = arr
print! arr2 # []
print! arr # MoveError: arr was moved in line 2
`);
            +pn{
                Pythonの奇妙な挙動としてよく知られている，リストの代入が参照のコピーであるという挙動は，この所有権の概念のためにErgでは起こらない．
            }
            +python(`# Python
list = []
list2 = list
list2.append(1)
print(list) # [1]
`);
            >
        >
        >
        +subsection?:(`type-system`){静的型システム}<
        +p{
            本節ではErgの静的型システムについて説明する．
            前提として，Python APIは動的型付けの前提で設計されている．
            これをなるべく使用感を損なわず静的に型付けするためには，従来の静的型付け言語のものよりも表現力の高い，強力な静的型システムが必要である．
            このためErg言語では，以下のような特筆すべき型システムを持つ．
            \listing{
              * トレイト
              * 制御構造に基づく型解析（control flow based type analysis）
              * オーバーロード型
              * 多相関数型
              * 構造的部分型
                ** Structural型
              * 直和型
              * 交差型
              * 依存型
              * 篩型
            }
        }
        +p{
            トレイトは複数の異なる型に共通する性質を表現し，統一的に扱うための型である．
            Pythonの抽象基底クラスに似ているが，後述する直和型や交差型などとして合成ができるなど，より柔軟である．
            Ergではトレイトを用いてメソッドのインターフェース化や演算子のオーバーロードなどを行うことができる．
            以下ではオブジェクトのhash値を計算する`__hash__`メソッドを統一的に扱うトレイトとして`Hash`を定義する例を示す．
        }
        +python(`# Hashは標準で定義されているトレイト
Hash = Trait {
    # Selfはトレイトを実装する具体的な型を表す
    __hash__: (self: Self) -> Int
}

myhash h: Hash = h.__hash__()
assert myhash(1) == 1
print! myhash("a") # -6206635357184620365
`);
        +p{
            対象のクラスに「実装」することで，そのクラスはトレイトに含まれる型として扱えるようになる．
            後述するStructural型を用いれば実装なしでもメソッドの存在だけでトレイトに含まれる型のように扱える．
        }
        +python(`C = Class { x = Int }
C|<: Hash|.
    __hash__ self = self.x.__hash__()
`);
        +p{
            オーバーロード（多重定義）型は，引数の型によって戻り値の型が変わる関数をアドホックに表現するための型である．
            Python APIには多くの（暗黙的な）オーバーロード関数が存在するためにこのオーバーロード型が存在しているが，
            あくまでPython APIを型付けするためのものであり，Erg側で定義する関数ではオーバーロードはできない．
            代わりに多相関数を用いる．
            以下では，オーバーロードされた関数の使用例を示す．
        }
        +python(`f: (Int -> Float) and (Str -> Str)
f = f(1) # f: Float
s = f("a") # s: Str
`);
        +p{
            多相関数型は，型変数と呼ばれる型上を動く変数を用いて抽象的な引数の型，戻り値の型を表現できる関数の型である．
            トレイトを用いて型変数に制約を与えることもできる．
            以下は，恒等関数idと2引数を加算する関数addの定義と使用例である．
        }
        +python(`id: |T|(T) -> T
id x = x
i = id(1) # i: Int
s = id("a") # s: Str

add: |A <: Add(R), R|(x: A, y: R) -> A.Output
add x, y = x + y
n = add(1, 2) # n: Nat
s = add("a", "b") # s: Str
`);
        +p{
            構造的部分型は，型の構造が一致していれば異なる型であっても同一視する型システムである．
            いわゆるダックタイピングを静的に型付けすることができる．
            構造的部分型の対義語として公称的部分型があるが，こちらはクラスの継承関係やトレイトの実装などによって明示的に部分型関係を宣言する．
            構造的部分型の方が強力であるが，公称的部分型の方が型検査の効率性が高い．
            Ergの部分型付けは基本的に公称的部分型だが，Structural型を用いてオプショナルに実現可能である．
            例えば，Str型の属性nameを持つオブジェクトは，すべて`Structural { .name = Str }`に含まれる．以下がその使用例である．
        }
        +python(`name n: Structural { .name = Str } = n.name

D = Class { .name = Int; .id = Nat }
D.
    new name, id = D { .name; .id }
E = Class { .name = Str; .id = Nat }
E.
    new name, id = E { .name; .id }

d = D.new 1, 2
e = E.new "a", 3

print! name(1) # ERROR
print! name(d) # ERROR
print! name(e) # "a"
`);
        +p{
            直和型は，複数の型のうちどれかの要素であることを要求する型である．
            T型とU型の直和型，すなわちT型かU型の可能性がある項の型は`T or U`型と表現される．
            これにより，例えば，異なる型の値を一つの変数に束縛することができる．
        }
        +python(`stringify x: Int or Str = match x:
    i: Int -> str i
    s: Str -> s

print! stringify 1 # "1"
print! stringify "a" # "a"
`);
        +p{
            交差型は，複数の型すべての要素であることを要求する型である．
            T型とU型の交差型，すなわちT型とU型の両方の要素である項の型は`T and U`型と表現される．
            これにより，例えば一つの型変数に対して複数のトレイトを制約として与えることができる．
            例えばErgの辞書のキーの型はEqトレイトとHashトレイトの両方を実装している必要があるが，これは交差型を用いて以下のように表現される．
        }
        +python(`dict1|K <: Eq and Hash| k: K, v = {k: v}

dict1 1, 2 # {1: 2}
dict1 1.0, 2 # ERROR
`);
        +p{
            制御構造に基づく型解析は，型の絞り込みを実現する機能である．
            例えば，iはNoneの可能性がある整数型（`Int or NoneType`）であるとする．この場合，`i + 1`はエラーになる．
        }
        +python(``i: Int or NoneType
i + 1 # TypeError: the type of `+`::lhs (the 1st argument) is mismatched
# expected: Add({1}..Obj)
# but found: Int or NoneType
# hint: cannot add Int and NoneType
``);
        +p{
            しかし`i`がNoneでないことを確かめられれば，`i + 1`は正当な式である．
            そこで，ifやassertなどの制御構造を用いて`i`が`NoneType`でないことを確かめることで，そのスコープ内では`i`型を`Int`に絞り込むことができる．
            これが制御構造に基づく型解析（control flow based type analysis）である．
            特にassertを使ってその場で型を絞り込む機能をassert castingと呼ぶ．
        }
        +python(`res = if i != None, do:
    i + 1 # OK
# iがNoneならばres == Noneなので，res: Int or NoneType
res: Int or NoneType
print! res # 2
assert res != None
res: Int
`);
        +p{
            依存型は多相型の中でも値をパラメータに持つ型である．
            通常の多相型では以下のように内部に型を持つことができるが，値は持つことができない．
        }
        +python(`a: Array(Int)`);
        +p{
            しかし依存型では，以下のように値を持つことができる．
            この場合は，依存型を用いて配列の長さを表す値を持つ配列型を表現している．
        }
        +python(`a: Array(Int, 3)

concat|T: Type, M: Nat, N: Nat|(l: Array(T, M), r: Array(T, N)): Array(T, M + N) = l + r

l: Array(Nat, 6) = concat [1, 2, 3], [4, 5, 6]
assert l == [1, 2, 3, 4, 5, 6]
`);
        +p{
            依存型は，多相関数型や篩型と組み合わせて使うこともできる．以下は，数値計算ライブラリnumpyの多次元配列型ndarrayのreshapeメソッドをErgの型システムで型付けした例である．
            reshapeの前後で要素数が変わらないことが静的に保証されている．
        }
        +python(`.NDArray(T, S).
    reshape: |T, Old: [Nat; _], S: {A: [Nat; _] | A.prod() == Old.prod()}|(
        self: .NDArray(T, Old),
        shape: {S},
    ) -> .NDArray(T, S)
`);
        >
        +subsection?:(`lang-server`){Language Server}<
        +p{
            Language Server（Erg Language Server）もRustで実装されており，コンパイラと同じライセンスで公開されている．
            Language Serverとは，対象言語のコーディングを支援する機能(エラー表示，補完機能，定義ジャンプなど)をエディタに提供するためのソフトウェアである．
            Language Server Protocol（LSP）\footnote-link(`https://microsoft.github.io/language-server-protocol/`);
            と呼ばれるプロトコルに対応することでエディタとの通信を可能にする．
        }
        +p{
            Language Serverも本プロジェクト採択前からプロトタイプとして開発を進めていたが，採択後は並列化，バグ修正と機能追加を行なった．

            Erg Language ServerはErgコンパイラのフロントエンドと連携することで動作する．
            `erg server`サブコマンドで起動することができるが，
            基本的にこのコマンドはエディタがLanguage Serverとの通信を確立するために使うものであり，ユーザが直接利用するものではない．
        }
        >
        +subsection{パッケージマネージャ} <
        +p{
            パッケージマネージャ（開発コードネーム: poise）はErg自身を用いて実装し，コンパイラと同じライセンスで公開されている．
            パッケージマネージャは`erg pack`サブコマンドで起動することができる．
        }
        +p{
            機能としては
            \listing{
                * パッケージの作成・初期化（`erg pack init`）
                * パッケージのインストール（`erg pack install`）
                * パッケージのアンインストール（`erg pack uninstall`）
                * パッケージのアップデート・依存関係の解決（`erg pack update`）
                * パッケージのビルド（`erg pack build`）
                * アプリケーションパッケージの実行（`erg pack run`）
                * パッケージのテスト（`erg pack test`）
                * パッケージのレジストリへの登録（`erg pack publish`）
            }
            が可能である．
        }
        +p{
            パッケージの作成・初期化機能では，パッケージの雛形ディレクトリやパッケージ情報を記述するファイル（`package.er`）を生成する．
        }
        +p{
            パッケージのインストール機能では，指定されたパッケージをレジストリから取得し，依存関係を解決してコンパイルし，
            出力された疑似実行可能ファイルをbinディレクトリに配置する．
            パッケージの指定がない場合はカレントディレクトリのローカルパッケージをインストールする．
        }
        +p{
            パッケージのアンインストール機能では，指定されたパッケージをローカルから削除する．
        }
        +p{
            パッケージのアップデート・依存関係の解決機能では，
            レジストリの最新情報を読み込んで，カレントディレクトリのローカルパッケージの依存関係を最新バージョンに更新する．
        }
        +p{
            パッケージのビルド機能では，カレントディレクトリのローカルパッケージをビルドする．
        }
        +p{
            アプリケーションパッケージの実行機能では，カレントディレクトリがアプリケーションパッケージならばビルドして実行する．
        }
        +p{
            パッケージのテスト機能では，カレントディレクトリのローカルパッケージのテストを実行する．
            テストは`tests`以下に配置されたテストスクリプトを実行することで行われる．
        }
        +p{
            パッケージのレジストリへの登録機能では，カレントディレクトリのローカルパッケージを検証し，
            レジストリに登録する（登録にはGitHubアカウントとGitHub CLIのインストールが必要となる）．

            パッケージマネージャ自身もアプリケーションパッケージとしてレジストリに登録されており，
            poiseを用いてpoise自身をビルド・アップデートすることができる．

            パッケージ情報については`package.er`というErgファイルに記述する．
            これはパッケージの名前，バージョン，依存関係などを記述する一種のDSL(ドメイン特化言語)となっている．

            パッケージのレジストリへの登録については、後述のパッケージレジストリの項で詳述する．
        }
        >
        +subsection{インストーラ}<
        +p{
            インストーラは，Erg言語のコンパイラ，パッケージマネージャ等を一括でインストールするためのスクリプトである．
            インストール先コンピュータのアーキテクチャに適合するコンパイラのバイナリと標準ライブラリをGitHub releaseから取得する．
            バイナリは最新バージョンのリリースによってCIがトリガーされGitHub releaseに自動でアップロードされるようにした．
            安定版のほか，開発版もインストール可能なオプションを実装した．
            また，パッケージマネージャは，ソースコードを取得しコンパイルすることでインストールする．
            インストーラはErgで実装されているが，Ergコンパイラがインストールされていないコンピュータ上では実行できないため，
            Pythonスクリプトバックエンドを使用してPythonスクリプトに変換し配布している．
        }
        >
        +subsection{パッケージレジストリ}<
        +p{
            パッケージレジストリはコードホスティングサイトGitHubを用いて構築した．
            パッケージマネージャは，パッケージレジストリのリポジトリへ圧縮されたパッケージをPull Requestとして送信し，
            メンテナの確認ののちmergeすることでパッケージの登録を行う．

            パッケージのmergeが完了すると，CIがトリガーされパッケージレジストリサイトの更新が自動的に行われる．
        }
        >
        +subsection{パッケージレジストリサイト}<
        +p{
            パッケージレジストリに登録されたパッケージの情報を閲覧するためのウェブサイトを構築した．
            このWebサイトは \href(`https://package.erg-lang.org`){https://package.erg-lang.org} で公開されている．
            図3にWebサイトのスクリーンショットを示す．
        }
        +fig-center(
            vconcat ?:align-center [
            include-image 400pt `img/pkg_erglang_org.jpg`;
            gap 10pt;
            textbox {図3: パッケージレジストリサイトのスクリーンショット};
        ]);
        +p {
            パッケージレジストリサイトでは，パッケージの検索やメタデータの閲覧が可能である．
            WebサイトはGitHub Pagesを用いて構築されており，パッケージレジストリのリポジトリに変更があるとCIがトリガーされ，
            Webサイトのhtmlコードが生成される．検索などの処理はクライアントサイドでJavaScriptを用いて行われるようにしており，
            現在のところ検索用サーバーなどは用意していない．
        }
        >
        +subsection{著名なPythonパッケージの型定義パッケージ群}<
        +p{
            ErgコンパイラはPythonの組み込みAPIや標準ライブラリの型定義を同梱しているが，
            サードパーティのPythonパッケージの型定義はErgパッケージとしてユーザにオンデマンドで提供されるか，
            ユーザ自身で型定義ファイルを記述する方式になっている．
        }
        +p{
            このうち著名なサードパーティのPythonパッケージについては，型定義パッケージを用意しレジストリに登録した．
            例としては，
            \listing {
                * numpy
                * pandas
                * matplotlib
                * requests
                * torch
                * torchvision
                * urllib3
                * erg_compiler (PythonパッケージとしてのErgコンパイラ)
            }
            などである．これらの型定義は`pytypes`というリポジトリ\footnote-link(`https://github.com/erg-lang/pytypes`);で管理されている．
        }
        >
    >
    +section{開発成果の特徴}<
    +p{
        本プロジェクトではPythonにトランスパイル可能な静的型付け言語Ergの開発を行った．
        ErgはPythonにトランスパイル可能・あるいは互換性を持つとされる他の言語と比べ，完全に静的型付けであり，
        Python APIの型定義を自前で行っている点が特徴である．
        また，Ergの強力な型システムにより，Python APIはその使用感をほとんど損なわない形で型定義されている．
        先行するHyやCoconut，Juliaなどの言語は動的型付けであり，本プロジェクトの解決したい問題に応えるものではない．
        MojoはPythonとの互換性を謳う静的型付け言語であるが，実際のAPIはMojo独自のものが多く，また開発環境も整備されていない．
    }
    +p{
        本プロジェクトではコンパイラ本体に加えて，Language Server，パッケージマネージャ，インストーラ，
        パッケージレジストリ，パッケージレジストリサイトなどの周辺ツールも開発した．
        Erg言語は単なる概念実証ではなく，実用プログラミング言語としての基盤を持っていると言える．
    }
    >
    +section{今後の課題}<
        +subsection{マクロ機構の実装}<
        +p{
            今後Erg言語をPythonユーザ等に広く認知・利用してもらうにあたって，
            Ergの基礎文法がPythonのそれとは表面的に乖離していることがユーザビリティの面で問題になりうる．

            例えば以下のような問題がある．
            これはPythonの`for`文の例である．
        }
        +python(`for i in range(10):
    print(i)
`);
        +p{
            同様のコードをErgで書くと以下のようになる．
        }
        +python(`for! range(10), i =>
    print!(i)
`);
        +p{
            基本的構造は同じだが，イテレーション可能オブジェクトとイテレーション変数の位置が逆転している．
            `for`文を導入せず関数呼び出しだけでループを実現しているという点ではErgの文法を好むユーザもいるかもしれないが，
            Pythonに慣れたユーザにとっては入力しづらいコードになっている．

            しかしErgはミニマルな基礎文法で豊富な機能を提供することを指向しており，`for`文のような制御構造を追加することは基本方針に反する．
        }
        +p{
            そこで，なるべくPythonの文法に近い形でErgコードを書けるようにするため，マクロ機構を導入することを検討している．
            現在構想されているマクロ機構はScala\footnote-link(`https://scala-lang.org`);やSATySFi\footnote-link(`https://github.com/gfngfn/SATySFi`);のような言語の衛生的マクロ機構を参考にしており，
            マクロの定義・呼び出しにも型検査を行うことで生成されるコードが必ず文法的・型的に正しいことを保証する．
        }
        >
        +subsection{ネイティブコードバックエンドの実装}<
        +p{
            \ref(`compiler`);節で述べたように，ErgコンパイラはPythonバイトコードを生成するバックエンドが現在の主要なバックエンドであるが，
            今後コンパイルターゲットを増やしていく予定である．
            特に本プロジェクト期間中は基本的機能の実装に留まったネイティブコードバックエンドの開発を進め，公開する予定である．
        }
        >
        +subsection{コンパイラの最適化}<
        +p{
            Ergコンパイラのパフォーマンスは，パッケージマネージャのソースコード（1000行弱）を数百ミリ秒でコンパイルできる程度である．
            実用的には問題ないと言えるが，まだまだ最適化の余地がある．
            簡易的なプロファイリングでは名前解決や型変数の除去処理がホットスポットであることが判明しており，
            名前解決器や型検査器の最適化を行うことでさらなるコンパイル速度の向上が期待できる．
        }
        >
        +subsection{型定義パッケージの拡充}<
        +p{
            前章で述べたように，Pythonの著名なサードパーティパッケージの型定義パッケージをレジストリに登録したが，
            これらは膨大な量のAPIがあるので，本プロジェクト期間中は主要なAPIに絞って型付けを行った．今後はより多くのAPIに対応する予定である．
            また，著名なPythonパッケージの中でまだ型定義パッケージを用意できていないものについても，今後対応していく予定である．
        }
        >
        +subsection{広報活動の実施}<
        +p{
            Erg言語はまだまだ発展途上であるものの，本プロジェクトの完遂によって実用プログラミング言語としての基盤が整ったと言えるので，
            ユーザ獲得へ向けて広報活動を実施していきたいと考える．
            PythonやRustなどプログラミング言語系のコミュニティの主催するカンファレンスに参加して登壇したり，
            ある程度Ergを学習したいというユーザが集まればワークショップを開催などしたいと考えている．
        }
        >
    >
    +section{実施計画書内容との相違点}<
    +p{
        当初本プロジェクトでは，採択以前から既にpycバックエンドを含めたコンパイラのプロトタイプが存在していたために，
        プロジェクト期間中はネイティブコードバックエンドとPythonインタプリタとのバインディング機構の実装に大きな重点を置く予定であった．
        しかしパッケージマネージャの実装を進めるうちにpycバックエンドやLanguage Serverに多くのバグや改善可能点が見つかり，
        これらの修正・改善を施して実用プログラミング言語としてのクオリティを向上させることに重点を移した．
    }
    >
    +section{成長の自己分析}<
    +p{
        実装能力の面での成長に関しては，コンパイラやLanguage Serverの再設計によって，コンパイラ実装は勿論のこと，
        並列処理など低レイヤーの知識を全般的に深めることができた．
    }
    +p{
        またErg言語の開発自体は本プロジェクト採択前から始めていたが，個人プロジェクトであったために欠けていた経験を得ることができた．
        例えば，定期報告の日時から逆算して実装機能の優先度を定め，それに基づいて開発を進める能力が向上した．
        また，各種会議や成果報告会での発表を通じて，他者に技術を噛み砕いて伝えるプレゼン能力が向上した．
        またそのようなプレゼンの中で，型理論やプログラミング言語理論について今までは実装レベルの知識しかなかったが，
        他者に淀みなく説明するためには理論的な知識も必要であることに気づき，それらの知識を更に深めたいと思うようになった．
    }
    >
    +section{付録}<
        +subsection{用語説明}<
            +description<
                +ditem{\gt{コンパイラ}}{}<
                +pn{
                    あるプログラミング言語で書かれたプログラムを，コンピュータが解釈・実行できる低水準言語あるいはそれに近い中間言語に変換するプログラム．
                    主な処理系がコンパイラである言語をコンパイラ言語と呼ぶ．これに対して，主な処理系がインタプリタである言語をインタプリタ言語と呼ぶが，
                    近年はインタプリタ言語の中でも実行時コンパイラ（JITコンパイラ）を持つものがあり，厳密な区別があるわけではない．
                    実際ErgもErgコンパイラによってPythonバイトコードに変換されるが，PythonバイトコードはPythonインタプリタによって実行されるため，
                    両方の性質を持つ．
                }
                >
                +ditem{\gt{トランスパイラ}}{}<
                +pn{
                    あるプログラミング言語で書かれたプログラムを，別のプログラミング言語で書かれたプログラムに変換するプログラム．
                    広い意味でのコンパイラの一種である．
                }
                >
                +ditem{\gt{API}}{}<
                +pn{
                    Application Programming Interfaceの略語．プログラムの機能を利用するためのインターフェースのことである．
                    プログラミング言語の文脈でAPIという場合，通常はライブラリやフレームワークが提供する関数やクラスなどを指す．
                }
                >
                +ditem{\gt{Python}}{}<
                +pn{
                    Guido van Rossumによって開発された汎用プログラミング言語．
                    現在はPython Software Foundationの主導によって開発が続けられている．
                    特にデータ分析や機械学習の分野で広く使われている．
                }
                >
                +ditem{\gt{CPython}}{}<
                +pn{
                    Pythonの標準実装であり，Python Software Foundationによって開発が続けられている．
                    CPython以外のPython実装としては，PyPyやJythonなどがある．
                    Ergのpycバックエンドは現在のところCPythonのみサポートしている．
                }
                >
                +ditem{\gt{Rust}}{}<
                +pn{
                    Graydon Hoareによって開発されたシステムプログラミング言語．現在はRust Foundationの主導によって開発が続けられている．
                    メモリ安全性と実行効率の両立を重視して設計されている．
                }
                >
                +ditem{\gt{構文糖}}{}<
                +pn{
                    構文糖または糖衣構文（syntactic sugar）とは，言語機能としては必須でないものの，プログラムの記述を簡潔にするためにある構文のことである．
                    構文糖はより基本的な構文に変換・分解される．例えばErgでは，パターンマッチは変数代入と条件分岐の組み合わせに分解される．
                }
                >
                +ditem{\gt{AST}}{}<
                +pn{
                    抽象構文木（Abstract Syntax Tree）の略語．プログラムの構文を木構造で表現したものである．
                }
                >
                +ditem{\gt{HIR}}{}<
                +pn{
                    高レベル中間表現（High-level Intermediate Representation）の略語．
                    多くのコンパイラは，ASTとコンパイルターゲットの間には大きな構造的差異があるために，直接ASTからコンパイルターゲットを生成することはせず，
                    間にいくつかの中間表現を経由する．ErgはASTとPythonバイトコードの間にHIRを経由する．
                    HIRは，大まかに言えば型情報付きのASTである．その他，いくつかの構文糖が脱糖されている．
                }
                >
                +ditem{\gt{LSP}}{}<
                +pn{
                    Language Server Protocolの略語．Language Serverとエディタの間で通信を行うためのプロトコルである．
                    Language Serverは，対象言語のコーディングを支援する機能（エラー表示，補完機能，定義ジャンプなど）をエディタに提供する．
                }
                >
            >
        >
        +subsection{関連Webサイト}<
        +p{
            \listing{
            * 公式サイト: \href(`https://erg-lang.org`){https://erg-lang.org}
            * パッケージレジストリサイト: \href(`https://package.erg-lang.org`){https://package.erg-lang.org}
            * GitHubリポジトリ: \href(`https://github.com/erg-lang/erg`){https://github.com/erg-lang/erg}
            * 公式ドキュメント: \href(`https://erg-lang.org/the-erg-book/`){https://erg-lang.org/the-erg-book/}
            }
        }
        >
    >
>
